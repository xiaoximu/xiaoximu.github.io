{"meta":{"title":"肖夕木的自习室","subtitle":"一个经济学专业学生的学习分享网站","description":"网站主要分享个人的一些经济，计量的学习笔记","author":"肖夕木","url":"http://xiaoximu.top","root":"/"},"pages":[{"title":"about","date":"2020-04-17T00:17:36.000Z","updated":"2020-04-17T06:54:12.325Z","comments":true,"path":"about/index.html","permalink":"http://xiaoximu.top/about/index.html","excerpt":"","text":"这里还没有想好写些什么"},{"title":"tags","date":"2020-04-16T14:09:14.000Z","updated":"2020-04-16T14:10:42.556Z","comments":false,"path":"tags/index.html","permalink":"http://xiaoximu.top/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-04-16T14:14:08.000Z","updated":"2020-04-16T14:15:06.970Z","comments":false,"path":"categories/index.html","permalink":"http://xiaoximu.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"R-数据包络分析-更复杂的DEA","slug":"R-数据包络分析-更复杂的DEA","date":"2020-05-20T12:33:37.000Z","updated":"2020-05-20T12:45:12.836Z","comments":true,"path":"R-数据包络分析-更复杂的DEA.html","link":"","permalink":"http://xiaoximu.top/R-%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%9C%E5%88%86%E6%9E%90-%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84DEA.html","excerpt":"本文不对DEA模型的推导过程进行详细介绍，只是简单介绍如何在R中进行相比于stata进行更为复杂的DEA分析。本文可能有错漏之处，还望海涵本文中的资料都可以在公众号“肖夕木的自习室”中回复dea获取","text":"本文不对DEA模型的推导过程进行详细介绍，只是简单介绍如何在R中进行相比于stata进行更为复杂的DEA分析。本文可能有错漏之处，还望海涵本文中的资料都可以在公众号“肖夕木的自习室”中回复dea获取 deaR “package”使用流程图在R中使用deaR这个包需要首先确认自己将要分析的数据是一个包含n个DMU的含有m个输入，s个输出的数据集。然后查看是否为模糊数据集，若是则将数据载入到R中，然后需要判断自己的数据是否为一个模糊数据，若是，则使用函数read_data_fuzzy在R中进行声明，若不是再判断自己的数据集是否为一个面板数据，若是则使用函数read_malmquist在R中声明。若二者都不是，则使用函数read_data进行声明。在对R声明了自己的数据集之后，就可以选取恰当的模型对自己的数据集进行分析了。在deaR“package”中提供了许许多多的模型。接下来本文会挑选一些常用的模型进行介绍 声明函数read_data12345678read_data(datadea = NULL,ni = NULL, #输入的个数，默认第一列为DMUno = NULL, #输出的个数，默认第一列为DMU dmus = 1, #设定DMU，可以用列名或数字来表示，默认为第一列inputs = NULL, #优先级高于ni的输入的列名或数字outputs = NULL, #优先级高于no的输出的列名或数字ud_inputs = NULL, #包含不想要的（好的）输入的数字向量ud_outputs = NULL) #包含不希望的（不良）输出的数字向量 read_malmquist12345read_malmquist(datadea,nper = NULL, #若为horizontal数据，则用来表示数据集时间有几期percol = NULL, #若为vertical数据，则用来指明时间的列名arrangement = c(\"horizontal\", \"vertical\"),...) read_data_fuzzy此函数本文不再介绍，有需要者可查询 deaR.pdf 具体模型在deaR“package”中有着诸多的模型，例如分析malmquist指数的malmquist_index函数，分析基础径向模型的model_basic函数，分析基础非径向模型的model_nonradial函数，分析方向向量模型的model_fdh函数，还有超效率模型等等，本文只挑选几个模型来介绍，至于更多的模型，读者可以查看deaR.pdf model_basicmodel_basic是最常用的基础径向模型，其具体语法格式为123456789101112131415161718model_basic(datadea,dmu_eval = NULL,dmu_ref = NULL,orientation = c(\"io\", \"oo\", \"dir\"),dir_input = NULL,dir_output = NULL,rts = c(\"crs\", \"vrs\", \"nirs\", \"ndrs\", \"grs\"),L = 1,U = 1,maxslack = TRUE,weight_slack_i = 1,weight_slack_o = 1,vtrans_i = NULL,vtrans_o = NULL,compute_target = TRUE,compute_multiplier = FALSE,returnlp = FALSE,...)datadea 包含n个DMU的数据集。此数据集含有m个输入，s个输出dmu_eval 一个数字向量表明被评价的DMU，默认为全体DMUdmu_ref 一个数字向量表明被参考的DMU，默认为全体DMUorientation 一个字符串，表明投入导向，产出导向或是direction。”io” (input oriented), “oo” (output oriented), or “dir(direc-tional).rts 确定规模收益情况，crs规模收益不变，”vrs”(variable), “nirs” (non-increasing), “ndrs” (non-decreasing) or “grs” (general-ized).compute_multiplier 逻辑变量值，如果为真，则计算对偶解 malmquist_indexmalmquist_index函数是计算malmquist指数的模型12345678malmquist_index(datadealist,dmu_eval = NULL,dmu_ref = NULL,orientation = c(\"io\", \"oo\"),rts = c(\"crs\", \"vrs\"),type1 = c(\"cont\", \"seq\", \"glob\"),type2 = c(\"fgnz\", \"rd\", \"gl\", \"bias\"),tc_vrs = FALSE)dmu_eval 一个数字向量表明被评价的DMU，默认为全体DMUdmu_ref 一个数字向量表明被参考的DMU，默认为全体DMUdatadealist 包含时间的DMUrts 决定规模收益，”crs” (constant) or”vrs” (variable).type1 一个字符串，选择参比方式”cont” (contemporary), “seq” (sequential) or “glob” (global).type2 一个字符串，选择分解方式”fgnz” (Fare et al. 1994), “rd” (Ray and Desli 1997), “gl”(generalized) or “bias” (biased).tc_vrs 逻辑值，如果为 FALSE，则它通过使用crs下的技术变化来计算vrs偏差Malmquist指数（Fare和Grosskopf 1996）。否则，它将使用vrs下的技术变化。 示例实例一123456789101112# Example 1. With dataset in wide format.# Replication of results in Wang and Lan (2011, p. 2768)data(\"Economy\")data_example &lt;- read_malmquist(datadea = Economy, nper = 5, arrangement = \"horizontal\", ni = 2, no = 1)result &lt;- malmquist_index(data_example, orientation = \"io\")mi &lt;- result$mieffch &lt;- result$ectech &lt;- result$tc 实例2123456789101112131415161718#model_bacic# Example 1. Basic DEA model with desirable inputs/outputs.# Replication of results in Charnes, Cooper and Rhodes (1981).data(\"PFT1981\")# Selecting DMUs in Program Follow Through (PFT)PFT &lt;- PFT1981[1:49, ]PFT &lt;- read_data(PFT, inputs = 2:6, outputs = 7:9 )eval_pft &lt;- model_basic(PFT, orientation = \"io\", rts = \"crs\")eff &lt;- efficiencies(eval_pft) #技术效率s &lt;- slacks(eval_pft) #松弛变量改进值lamb &lt;- lambdas(eval_pft) #约束条件tar &lt;- targets(eval_pft) #目标值（投影值）ref &lt;- references(eval_pft) #参考标杆returns &lt;- rts(eval_pft) #规模收益状态与线性组合系数之和","categories":[],"tags":[{"name":"R语言","slug":"R语言","permalink":"http://xiaoximu.top/tags/R%E8%AF%AD%E8%A8%80/"}]},{"title":"stata:数据包络分析（DEA）简明教程","slug":"stata-数据包络分析（DEA）简明教程","date":"2020-05-02T08:47:39.000Z","updated":"2020-05-02T12:54:33.707Z","comments":true,"path":"stata-数据包络分析（DEA）简明教程.html","link":"","permalink":"http://xiaoximu.top/stata-%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%9C%E5%88%86%E6%9E%90%EF%BC%88DEA%EF%BC%89%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B.html","excerpt":"数据包络分析（DEA）是是由美国著名运筹学家 A.Charnes（查恩斯）、W.W.Cooper（库铂）、E.Rhodes（罗兹）于 1978 年首先提出，在相对效率评价概念基础上发展起来的一种非参数检验方法。此文章主要介绍如何在stata中进行DEA分析以及进行boostrap检验，用到的命令为tenonradial，teradialbc等。需要说明的是，尽管此命令的运算速度与矩阵的最大处理量要优于dea命令，但是其仍有一些限制。","text":"数据包络分析（DEA）是是由美国著名运筹学家 A.Charnes（查恩斯）、W.W.Cooper（库铂）、E.Rhodes（罗兹）于 1978 年首先提出，在相对效率评价概念基础上发展起来的一种非参数检验方法。此文章主要介绍如何在stata中进行DEA分析以及进行boostrap检验，用到的命令为tenonradial，teradialbc等。需要说明的是，尽管此命令的运算速度与矩阵的最大处理量要优于dea命令，但是其仍有一些限制。 DEA模型简介技术效率的概念在数据包络分析中，技术效率是指一个生产单元（DMU）的生产水平达到该行业技术水平的程度。技术效率可以从投入和产出两个角度来衡量，在投入既定的情况下，技术效率由产出最大化的程度来衡量。在产出既定的情况下，技术效率由投入最小化的程度来衡量。当然，在计算TFP的过程中，一般都是投入既定的。下面举一个一种投入一种产出时的例子，来帮助我们理解技术效率的概念。 单位 $x$（投入） $y$（产出） $y/x$ $y/x$(标准化) A 2 1 0.5 0.625 B 3 2 0.667 0.533 C 4 3 0.75 0.938 D 5 4 0.8 1.00 E 5 2 0.4 0.5 在此表中，$y/x$反应各个生产单元技术效率的高低，$y/x$(标准化)是将各单元的$y/x$除以其中的最大值。这样就是为了更好的比较这一数值。当涉及多个产出时，就会对各个投入与产出赋予一定的权重，然后分别加权，计算产出投入比。如： v = v_1x_1+v_2x_2+...+v_nx_nu=u_1y_1+u_2y_2+...+u_ny_n则产出投入比为$u/v$数据包络分析就是在讨论如何通过数据本身来获得权重，从而计算各个DMU的技术效率。 径向距离模型此命令径向效率的度量方法采用的是Debreu–Farrell(Debreu 1951; Farrell 1957)方法。假设有$k$个$DMU$。对于$DMUK$，有$N$种投入，记为$x_k =（x{k1},…,x{kN}) \\in R^N$,有$M$种产出，记为$y_k =（x{k1},…,x_{kM}) \\in R^M$。然后我们假设在技术条件$T$下产出$y$由投入$x$产出，数学表达为： T = \\{(x,y):y\\ are\\ producible\\ by\\ x\\}那么在科技$T$下，生产可能集表示为： P(x) = \\{y:(x,y) \\in T\\}投入的需求集表示为： P(y) = \\{x:(x,y) \\in T\\}以生产可能集为例，技术效率就表示为，某个给定数据点与生产可能集边界的距离。若以DEA模型来测量此种技术效率从，则对于$k$个$DMU$，每个$DMU$有$N$种投入，$M$种产出的数据集来说。Debreu–Farrell(Debreu 1951; Farrell 1957)的以产出为导向的估计方法，可以通过下述线性规的方程式来表示，对于每一个数据点$k(k= 1,2,3…K)$ F_k^o(y_k,x_k,y,x|CRS)=max\\theta \\\\ s.t. \\sum_{k=1}^Kz_ky_{km} \\geq y_{km}\\theta_m,m=1,...,M \\\\ \\sum_{k=1}^Kz_kx_{kn} \\leq x_{kn}\\theta_n,n=1,...,N \\\\ z_k \\geq 0其中$y$是一个$K\\times M$的产出矩阵，$x$是一个$K\\times N$的投入矩阵。估计$P(x)$是最小的包围面（smallest convex free-disposal hull ）。上述线性规划求解的是规模报酬不变（CRS）的技术效率。在其他关于规模报酬的假设下，只需改变$zk$的约束，例如规模报酬可变（VRS），设置$\\sum{k=1}^Kz_k=1$即可。 非径向效率模型此命令的非径向效率测量方法是Russell（Färe and Lovell 1978;Färe, Grosskopf, and Lovell 1994a）法。则对于以产出为导向的非径向量度定义为： RM_k^o(y_K,x_K,y,x|CRS)=max \\{M^{-1}\\sum_{m=1}^M \\theta_m: (\\theta_1y_{k1},...,\\theta_my_{km}\\in P(x),\\theta_m\\geq0,m=1,...M)\\}其线性规划方程式定义为： RM_k^o(y_K,x_K,y,x|CRS)=M^{-1}max\\sum_{m=1}^M \\theta_m \\\\ s.t. \\sum_{k=1}^Kz_ky_{km} \\geq y_{km}\\theta_m,m=1,...,M \\\\ \\sum_{k=1}^Kz_kx_{kn} \\leq x_{kn}\\theta_n,n=1,...,N \\\\ z_k \\geq 0对径向模型使用Boostrap进行假设检验主要介绍此命令规模收益的两个假设检验，首先是： Test \\neq 1: H_0: T\\ is\\ globally\\ CRS \\\\ H_1: T\\ is\\ VRS如果假设$H_0$被拒绝，则可以进行下述假设检验： Test \\neq 2: H_0': T\\ is\\ globally\\ NIRS \\\\ H_1: T\\ is\\ VRS也是就是说先查看此技术条件下是否是规模报酬不变的，若不是再看是否是NIRS（Non-Decreasing Returns to scale）的。 stata命令的实现tenonradial命令tenonradial使用非径向模型RM估计技术效率，语法详情：tenonradial outputs = inputs [(ref outputs = ref inputs)] [if] [in] [,rts(rtsassumption) base(basetype) reference(varname) tename(newvar) noprint]其中output是产出变量input是投入变量ref outputs是产出变量的个数ref inputs是投入变量的个数rts(rtsassumption)指定规模收益假设，有CRS,VRS,NIRS三种base(basetype) 设置最优化的方向，即面向产出base(output)，面向投入base(input)reference(varname)设定技术参考集tename(newvar)产生newvar，其包含非径向测量的技术效率。noprint 取消估算详细信息，数据描述和参考集。 teradialbc命令teradialbc命令使用径向模型估计技术效率，语法详情：teradialbc outputs = inputs [(ref outputs = ref inputs)] [if] [in] [,rts(rtsassumption)base(basetype) reference(varname) subsampling kappa(#) smoothed heterogeneous reps(#) level(#) tename(newvar) tebc(newvar) biasboot(newvar) varboot(newvar) biassqva(newvar)telower(newvar) teupper(newvar) noprint nodots]其区别主要在于Boostrap部分，详细内容参见help teradialbc teradialbc命令的函数支持stata需要已下载kdens bw()与mm quantile() nptestind命令nptestind进行独立性检验 nptestrts命令nptestrts进行规模收益检验 实例应用数据来源于Charnes, Cooper, and Rhodes (1981)，并人为的产生一个新变量dref来说明新命令的功能12345678910set seed 717117use ccr81generate dref &#x3D; x5 !&#x3D; 10teradial y1 y2 y3 &#x3D; x1 x2 x3 x4 x5, rts(crs) base(output) reference(dref) tename(TErdCRSo)teradial y1 y2 y3 &#x3D; x1 x2 x3 x4 x5, rts(nirs) base(output) reference(dref) tename(TErdNRSo) noprintteradial y1 y2 y3 &#x3D; x1 x2 x3 x4 x5, rts(vrs) base(output) reference(dref) tename(TErdVRSo) noprinttenonradial y1 y2 y3 &#x3D; x1 x2 x3 x4 x5, rts(crs) base(output) reference(dref) tename(TEnrCRSo) noprinttenonradial y1 y2 y3 &#x3D; x1 x2 x3 x4 x5, rts(nirs) base(output) reference(dref) tename(TEnrNRSo) noprinttenonradial y1 y2 y3 &#x3D; x1 x2 x3 x4 x5, rts(vrs) base(output) reference(dref) tename(TEnrVRSo) noprintlist TErdCRSo TErdNRSo TErdVRSo TEnrCRSo TEnrNRSo TEnrVRSo in 1&#x2F;7分别使用径向与非径向模型测量三种规模收益状况下的技术效率。接下来使用nptestind进行boostrap检验12345678910111213141516matrix testsindpv &#x3D; J(2, 3, .)matrix colnames testsindpv &#x3D; CRS NiRS VRS matrix rownames testsindpv &#x3D; output-based input-basednptestind y1 y2 y3 &#x3D; x1 x2 x3 x4 x5, rts(crs) base(output) reps(999) alpha(0.05)matrix testsindpv[1,1] &#x3D; e(pvalue)nptestind y1 y2 y3 &#x3D; x1 x2 x3 x4 x5, rts(nirs) base(output) reps(999) alpha(0.05) noprintmatrix testsindpv[1,2] &#x3D; e(pvalue)nptestind y1 y2 y3 &#x3D; x1 x2 x3 x4 x5, rts(vrs) base(output) reps(999) alpha(0.05) noprintmatrix testsindpv[1,3] &#x3D; e(pvalue)nptestind y1 y2 y3 &#x3D; x1 x2 x3 x4 x5, rts(crs) base(input) reps(999) alpha(0.05) noprintmatrix testsindpv[2,1] &#x3D; e(pvalue)nptestind y1 y2 y3 &#x3D; x1 x2 x3 x4 x5, rts(nirs) base(input) reps(999) alpha(0.05) noprintmatrix testsindpv[2,2] &#x3D; e(pvalue)nptestind y1 y2 y3 &#x3D; x1 x2 x3 x4 x5, rts(vrs) base(input) reps(999) alpha(0.05) noprintmatrix testsindpv[2,3] &#x3D; e(pvalue)matrix list testsindpvP值结果如下：1234 CRS NiRS VRSoutput-based .06906907 .25625626 .04804805 input-based .03703704 .001001 .23323323 Malmquist指数Malmquist指数的计算与分解公式此处不再列出，只是用程序来举例123456789use pwt56, clearreshape wide y k l, i(nu country) j(year)teradial y1965 &#x3D; k1965 l1965 (y1965 &#x3D; k1965 l1965), rts(crs) base(output) tename(F11) noprintteradial y1990 &#x3D; k1990 l1990 (y1965 &#x3D; k1965 l1965), rts(crs) base(output) tename(F21) noprintteradial y1965 &#x3D; k1965 l1965 (y1990 &#x3D; k1990 l1990), rts(crs) base(output) tename(F12) noprintteradial y1990 &#x3D; k1990 l1990 (y1990 &#x3D; k1990 l1990), rts(crs) base(output) tename(F22) noprintgenerate mpi &#x3D; sqrt(F12 &#x2F; F22 * F22 &#x2F; F21)generate effch &#x3D; F11 &#x2F; F22generate techch &#x3D; mpi &#x2F; effch PS：文章中所用到的学习资料为《数据包络分析方法与MaxDea软件》与文章“Nonparametric frontier analysis using Stata”，此资料可在我的公众号“肖夕木的自习室”中回复dea获取。至于文中的数据文件可以自行在stata上下载，当然，在我的dea学习资料中也有包含。","categories":[{"name":"计量","slug":"计量","permalink":"http://xiaoximu.top/categories/%E8%AE%A1%E9%87%8F/"}],"tags":[{"name":"DEA","slug":"DEA","permalink":"http://xiaoximu.top/tags/DEA/"}]},{"title":"mata学习-《Coding with Mata in Stata》","slug":"stata-mata学习","date":"2020-04-27T06:45:52.000Z","updated":"2020-04-29T01:43:14.426Z","comments":true,"path":"stata-mata学习.html","link":"","permalink":"http://xiaoximu.top/stata-mata%E5%AD%A6%E4%B9%A0.html","excerpt":"mata是stata的一种编程语言，类似于c或是c++等语言，其基本操作是对矩阵的操作。本篇文章只是mata语言的一个简明教程，可以帮助你认识程序中的各个大的框架，了解mata的一些基础知识。而没有深入的探讨mata中的各个函数。关于mata的中文资料很少，只是看到连玉君老师分享过一篇文章。希望本文能对他人学习mata提供一些帮助。mata学习的英文资料，可关注我的公众号：“肖夕木的自习室” 回复mata获取","text":"mata是stata的一种编程语言，类似于c或是c++等语言，其基本操作是对矩阵的操作。本篇文章只是mata语言的一个简明教程，可以帮助你认识程序中的各个大的框架，了解mata的一些基础知识。而没有深入的探讨mata中的各个函数。关于mata的中文资料很少，只是看到连玉君老师分享过一篇文章。希望本文能对他人学习mata提供一些帮助。mata学习的英文资料，可关注我的公众号：“肖夕木的自习室” 回复mata获取 1. 为什么学习mata开始学习mata是因为在stata中许多程序都是用mata编写的，若是想将这些程序改进以适用于自己的需要，则必然要学习mata 2. 在stata中使用mata2.1 命令行的使用mata可以直接在stata的命令窗口中使用，输入命令：1mata即进入mata工作区，接下来输入的所有命令都将被解释成mata命令。输入：1end退出mata工作区，返回到stata平时使用的工作区。 注意：在mata工作区中定义的所有函数和矩阵在你退出mata工作区后，都会保存在mata工作区中，当再输入mata时，可以调用之前定义的所有函数和矩阵。 2.2 在.do文件中使用mata在.do文件中可以多次使用mata命令，而且每次退出后，再进入mata工作区时，进入的是同一个工作区 2.3 在.ado文件中使用mata有关使用mata生成新的命令的内容见section 7 3. mata中的矩阵3.1 create矩阵，向量和标量3.1.1 创建矩阵有两种创建矩阵的方式，一种是创建整个矩阵，用\\分行，用,分隔列。如创建一个2行2列的矩阵：1A&#x3D;(1,2\\3,4)或者是创建一个空矩阵，例如创建一个2行三列的空矩阵：1B&#x3D;J(2,3,.)然后填充数据：123456B[1,1] &#x3D; 5B[1,2] &#x3D; 6B[1,3] &#x3D; 7B[2,1] &#x3D; 8B[2,2] &#x3D; 9B[2,3] &#x3D; 10可以为矩阵命名，命名规则与大部分语言类似，即以字母，数字，下划线组合，但不能以数字为首字母。mata命名区分大小写。如果矩阵已经被赋值，那么再对此矩阵赋值会覆盖之前的赋值。输入变量的名字来显示1234567B 1 2 3 +-------------+ 1 | 5 6 7 | 2 | 8 9 10 | +-------------+ 3.1.2 创建向量向量就是$1\\times n$或$n \\times 1$的矩阵，向量的设置，此处不再赘述，但是要指出的是增加&#39;代表转置，如：1f &#x3D; (1, 2, 3)&#39;与1f &#x3D; ( 1 \\ 2 \\ 3 )等价也可以使用一系列数字来创建一个列向量或是行向量，如：123456789101112131415g &#x3D; (3::6)g 1 +-----+ 1 | 3 | 2 | 4 | 3 | 5 | 4 | 6 | +-----+g &#x3D; (3..6)g 1 2 3 4 +-----------------+ 1 | 3 4 5 6 | +-----------------+ 3.1.3 创建标量一个标量就是一个$1\\times1$的矩阵，如:a = 2但是需要注意的是矩阵命令区分标量和$1\\times1$矩阵 3.2 从stata访问数据首先退出mata，然后获取数据集1webuse auto.dta 3.2.1 创建一个数据的副本st data(colvector, rowvector)可以通过变量名复制在stata中的数据。如；1X &#x3D; st_data(.,(&quot;mpg&quot;, &quot;rep78&quot;, &quot;weight&quot;))创建了一个包含变量mpg,rep78,weight的数据集。，也可以复制其子矩阵，如：1X &#x3D; st_data((1::5\\7::9),(&quot;mpg&quot;, &quot;rep78&quot;, &quot;weight&quot;))获取1至5与7至9行的子矩阵。还可以使用函数st_data(matrix, rowvector)将对应编号的变量的值取出，如:1234567891011121314151617181920212223242526X &#x3D; st_data((1::5\\7::9),(3, 4, 7))X 1 2 3 +----------------------+ 1 | 22 3 2930 | 2 | 17 3 3350 | 3 | 22 . 2640 | 4 | 20 3 3250 | 5 | 15 4 4080 | 6 | 26 . 2230 | 7 | 20 3 3280 | 8 | 16 3 3880 | +----------------------+ X &#x3D; st_data((1,5\\7,9),(&quot;mpg&quot;, &quot;weight&quot;, &quot;rep78&quot;)) X 1 2 3 +----------------------+ 1 | 22 2930 3 | 2 | 17 3350 3 | 3 | 22 2640 . | 4 | 20 3250 3 | 5 | 15 4080 4 | 6 | 26 2230 . | 7 | 20 3280 3 | 8 | 16 3880 3 | +----------------------+取出内存中已载入数据集auto1至5行与7至9行，与3，4，7列的数据存入矩阵X中。更多请查看help mata:st_data 3.2.2 creating a view on the data使用st view(X, colvector, rowvector)创建一个当前数据集的view(类似于把变量或某些行内的数据取出)，如：12X &#x3D; .st_view(X, ., (&quot;mpg&quot;, &quot;weight&quot;, &quot;rep78&quot;))该命令的意思是创建一个包含变量mpg，weight，rep78的值的矩阵X。使用st subview(Y, X, colvector, rowvector)根据矩阵X创建一个新矩阵Y，如：12st_view(X, ., .)st_subview(Y, X, (1::5\\7::9), (3,4,7))用X矩阵的1到5行与7到9行的3，4，7列创建一个新矩阵Y。 3.2.3 copy vs. view这里所说的copy与view是指st_data与st_view两个函数的区别。st_data与st_view两个函数所实现的功能相似，但是，st_data运算更加快速，且不改变stata内存中的数据。注意：对于字符串变量需使用st_sdata与st_sview函数。 3.3 管理mata的工作区使用命令mata describe查看mata中的所有变量。使用命令mata clear删除mata工作空间的所有变量。特定矩阵的删除可以使用命令mata drop namelist 3.4 基本的矩阵操作3.4.1 矩阵的转置矩阵的转置前文已说 3.4.2 矩阵的分区创建矩阵E123456789E &#x3D; (1,2,5,6,7\\3,4,8,9,10\\3,4,1,2,3\\5,6,4,5,6)E 1 2 3 4 5 +--------------------------+ 1 | 1 2 5 6 7 | 2 | 3 4 8 9 10 | 3 | 3 4 1 2 3 | 4 | 5 6 4 5 6 | +--------------------------+使用[]进行矩阵的分区如：1234567E[2, 3]8E[2,.]1 2 3 4 5+--------------------------+1 | 3 4 8 9 1 0 |+--------------------------+注意可以通过range subscripts提取矩阵的2到3行与2到4列。如下述命令。123456E[|2, 2\\ 3, 4|]1 2 3+-------------+1 | 4 8 9 |2 | 4 1 2 |+-------------+也可以通过一个连续范围提取矩阵的2到3行与2到4列，如：123456E[(2::3), (2..4)]1 2 3+-------------+1 | 4 8 9 |2 | 4 1 2 |+-------------+注意：第一种方法的运算速度快于第二种。 提取单个行和单个列组成矩阵：123456E[(1\\ 4), (3, 5, 2)]1 2 3+-------------+1 | 5 7 2 |2 | 4 6 6 |+-------------+更加一般化的是，可以用两个定义好的变量来提取行和列，如；12345678r &#x3D; (1\\ 4)c &#x3D; (3, 5, 2)E[r,c]1 2 3+-------------+1 | 5 7 2 |2 | 4 6 6 |+-------------+ 注意；尽管stata认为将第一个下标向量指定为列向量，将第二个下标向量指定为行向量是一种好方法，但是这并不是必须的。 3.4.3 提取对角线并创建对角矩阵diagonal(A)可以提取矩阵的对角线上的元素，并以列向量的形式表示，如：12345678910111213141516A &#x3D; (1,2,3\\4,5,6\\7,8,9)A 1 2 3 +-------------+ 1 | 1 2 3 | 2 | 4 5 6 | 3 | 7 8 9 | +-------------+b &#x3D; diagonal(A)b 1 +-----+ 1 | 1 | 2 | 5 | 3 | 9 | +-----+diag(b)创建一个对角线为b向量的矩阵，如:12345678 diag(b)[symmetric] 1 2 3 +-------------+ 1 | 1 | 2 | 0 5 | 3 | 0 0 9 | +-------------+ 3.4.4 提取上下三角矩阵lowertriangle(A)提取下三角矩阵，uppertriangle(A)提取上三角矩阵。 3.4.5 对矩阵进行排序sort（X,idx）返回一个以idx列排序的矩阵X，如sort（X,1）即以第一列对X进行排序 123456789101112131415X &#x3D; (2, 3, 1\\ 2, 2, 2\\ 1, 1, 3)X1 2 3+-------------+1 | 2 3 1 |2 | 2 2 2 |3 | 1 1 3 |+-------------+sort(X,1)1 2 3+-------------+1 | 1 1 3 |2 | 2 3 1 |3 | 2 2 2 |+-------------+ 使用help mata sort()可获取更多信息。 3.5 基本的矩阵运算符号+，$\\times$，-，/，^ 接下来的运算符号，以例子的形式讲解。设定矩阵： a = (1..5) b = (6::10) c = 3 矩阵的 + 与 $\\times$与数学上的定义相同 123456d&#x3D;a+c*ad1 2 3 4 5+--------------------------+1 | 4 8 12 16 20 |+--------------------------+ 3.6 矩阵乘法函数cross(X, Z)可以计算X’Z。cross(X, Z)函数计算有以下三点优势 自动忽略缺省值 运算速度快 占用空间小 3.6.1 Element-by-element operators即矩阵间，各个内部元素（后文称之为colon）的相互运算，而不是两个矩阵的运算。运算符： :* :/ :^，例如：12345678x &#x3D; (1, 2, 3)y &#x3D; (4, 5, 6)x:*y1 2 3 1 2 3 +----------------+ 1 | 4 10 18 | +----------------+ 就是各个元素对应的乘积。 3.6.2 关系与逻辑运算符等价运算符：等于： ==不等于 !=此关系运算符用于标量，向量和矩阵。关系运算符：&lt; &gt; &gt;= &lt;=colo relational operator，在之前的运算符前加上:即可，如:== 例子： 12345678G &#x3D; (1, 2 \\ 3, 4)H &#x3D; (1, 5 \\ 6, 4)G :&#x3D;&#x3D; H 1 2 +---------+ 1 | 1 | 2 | 0 1 | +---------+ 逻辑运算符：&amp; &amp;&amp; 和| || 或同样可以加: 3.7 一些特殊矩阵的创建3.7.1 创建一个含相同元素的矩阵123456J(2, 3, 0) 1 2 3 +-------------+ 1 | 0 0 0 | 2 | 0 0 0 | +-------------+ 3.7.2 创建一个单位阵12345678 I(3)[symmetric] 1 2 3 +-------------+ 1 | 1 | 2 | 0 1 | 3 | 0 0 1 | +-------------+ 3.7.3 创建单位向量12345e(2, 5) 1 2 3 4 5 +---------------------+ 1 | 0 1 0 0 0 | +---------------------+ 3.7.4 创建随机矩阵123456uniform(2, 3) 1 2 3 +-------------------------------------------+ 1 | .3488717046 .2668857098 .1366462945 | 2 | .0285568673 .8689332692 .350854896 | +-------------------------------------------+ uniform()创建的是一个0，1之间的随机数。uniformseed(newseed)与stata中一样可以设立一个随机种子，以使结果具有可重复性。mata无法直接生成随机正态分布的矩阵，但可以通过嵌套的方法来实现，如： 123456invnormal(uniform(2,3)) 1 2 3 +----------------------------------------------+ 1 | -1.467610024 -.4583014284 .1385652864 | 2 | 1.155176934 -.8249166005 1.241333377 | +----------------------------------------------+ 3.8 逆与线性代数mata有多种计算矩阵逆的函数：luinv(A) A为满秩，方阵cholinv(A) A为正定对称矩阵invsym(A) generalized inverse of positive-definite, symmetric matrix Amata也提供了一些方法来求解线性方程组$AX=B$：lusolve(A,B) A为满秩，方阵。cholinv(A) A为正定对称矩阵。help m4 solvers获得更多相关函数一个使用auto.data数据进行线性回归的例子： 1234y &#x3D; st_data(.,&quot;price&quot;)X &#x3D; st_data(.,(&quot;mpg&quot;, &quot;weight&quot;))X &#x3D; X, J(rows(X),1,1)b &#x3D; invsym(X’*X)*X’*y 4. Controlling the flow此处的流程控制语句与c中类似4.1 循环语句while-loop： 123while (expr) &#123;stmt&#125; 例如: 1234567n &#x3D; 5i &#x3D; 1while (i&lt;&#x3D;n) &#123;printf(&quot;i&#x3D;%g\\n&quot;, i)i++&#125;printf(&quot;done\\n&quot;) for-loop123for (expr1; expr2; expr3) &#123;stmts&#125; 例如:12345n &#x3D; 5for (i&#x3D;1; i&lt;&#x3D;n; i++) &#123;printf(&quot;i&#x3D;%g\\n&quot;, i)&#125;printf(&quot;done\\n&quot;) do循环123do &#123;stmt&#125; while (exp) 4.2 条件语句if condition123 if (expr) &#123;stmt&#125; 5. 编码 mata 函数mata允许创建一些新函数，例如:12345function zeros(c)&#123;a &#x3D; J(c, 1, 0)return(a)&#125; 输出结果12345678b &#x3D; zeros(3) b 1 +-----+ 1 | 0 | 2 | 0 | 3 | 0 | +-----+ 5.1 declarationsmata中不需要像其他语言中那样声明创建变量的类型，但是mata建议你声明。element type：transmorphic, numeric, real,complex, string, pointerorganizational type：matrix, vector, rowvector, colvector, scalar但是，mata中可以强制要求声明： 1set matastrict on 6. Controlling the flow此处的流程控制语句与c中类似6.1 循环语句while-loop： 123while (expr) &#123;stmt&#125; 例如: 1234567n &#x3D; 5i &#x3D; 1while (i&lt;&#x3D;n) &#123;printf(&quot;i&#x3D;%g\\n&quot;, i)i++&#125;printf(&quot;done\\n&quot;) for-loop123for (expr1; expr2; expr3) &#123;stmts&#125; 例如： 12345n &#x3D; 5for (i&#x3D;1; i&lt;&#x3D;n; i++) &#123;printf(&quot;i&#x3D;%g\\n&quot;, i)&#125;printf(&quot;done\\n&quot;) do-循环 123do &#123;stmt&#125; while (exp) 6.2 条件语句1234 if condition if (expr) &#123;stmt&#125; 7. 编码 mata 函数mata允许创建一些新函数，例如： 123456789101112131415function zeros(c)&#123;a &#x3D; J(c, 1, 0)return(a)&#125;输出结果b &#x3D; zeros(3) b 1 +-----+ 1 | 0 | 2 | 0 | 3 | 0 | +-----+ 7.1 declarationsmata中不需要像其他语言中那样声明创建变量的类型，但是mata建议你声明。element type：transmorphic, numeric, real,complex, string, pointerorganizational type：matrix, vector, rowvector, colvector, scalar例如之前的zeros()程序： 123456real colvector zeros(real scalar c)&#123;real colvector aa &#x3D; J(c,1,0)return(a)&#125; 但是，mata中可以强制要求声明： 1set matastrict on 7.2 传递参数（stata中的argument）function中如果有多个需要传递的参数，则这些参数可以用,隔开，对于之前的zero()如： 123456real matrix zeros(real scalar c, real scalar r)&#123; real matrix A A &#x3D; J(c, r, 0) return(A)&#125; mata中的函数还允许设定可选的参数，可选参数通过’|’隔离来设置，同样对于之前的zero()函数： 1234567real matrix zeros(real scalar c,| real scalar r)&#123;real matrix Aif (args()&#x3D;&#x3D;1) r &#x3D; 1A &#x3D; J(c, r, 0)return(A)&#125; 函数args()决定参数的数量。help m2 syntax获取更多信息。 注意： mata传递的是参数的地址，而不是参数的值。 7.3 返回值使用函数return(expr)会结束当前函数进程，且返回相应的值。如：123456789real matrix zeros(real scalar c,| real scalar r)&#123;if (args()&#x3D;&#x3D;1) &#123; return(J(c, 1, 0))&#125;else &#123; return(J(c, r, 0))&#125;&#125;此时会返回一个矩阵如果一个函数不返回任何东西，则称此函数为void，例如：123456789void zeros(real matrix A, real scalar c,| real scalar r)&#123;if (args()&#x3D;&#x3D;1) &#123;A &#x3D; J(c, 1, 0)&#125;else &#123;A &#x3D; J(c, r, 0)&#125;&#125;此时函数不会返回任何值。 7.4 .mo和.mlib文件使用mata mosave可以将函数保存至文件中，这样在stata中可以随时调用，而不用重新定义，例如创建一个.do文件：1234567891011version 10mata:real matrix zeros(real scalar c,| real scalar r)&#123;real matrix Aif (args()&#x3D;&#x3D;1) r &#x3D; 1A &#x3D; J(c, r, 0)return(A)&#125;mata mosave zeros(), replaceend运行后，会创建一个zeros.mo文件存储在工作目录下。如果你关闭stata，再打开stata，该函数同样可以运行。多个函数文件可以存储在.mlib文件中。 8. 使用mata编码stata命令8.1 一个例子创建一个ols回归的命令,文件保存至一个.ado文件，即可调用。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849program define ols, eclassversion 10.0syntax varlist(numeric) [if] [in]gettoken depvar indepvar: varlistmarksample tousemata: m_ols(\"‘varlist’\", \"‘touse’\")tempname b Vmatrix ‘b’ = r(b)’matrix ‘V’ = r(V)local N = r(N)matname ‘b’ ‘indepvar’ _cons, c(.)matname ‘V’ ‘indepvar’ _consereturn post ‘b’ ‘V’, depname(‘depvar’) obs(‘N’) esample(‘touse’)ereturn local cmd = \"ols\"ereturn displayendcapture mata mata drop m_ols()version 10mata:void m_ols(string scalar varlist, string scalar touse)&#123;real matrix M, X, Vreal colvector y, breal scalar n, k, s2M = X = y = .st_view(M, ., tokens(varlist), touse)st_subview(y, M, ., 1)st_subview(X, M, ., (2\\.))n = rows(X)k = cols(X)XX = cross(X,1,X,1)if (rank(XX) &lt; k+1) &#123;errprintf(\"near singular matrix\\n\")exit(499)&#125;Xy = cross(X,1,y,0)b = cholsolve(XX,Xy)e = y - (X, J(n,1,1))*bs2 = (e’e)/(n-k)V = s2*cholinv(XX)st_eclear()st_matrix(\"r(b)\", b)st_matrix(\"r(V)\", V)st_numscalar(\"r(N)\", n)&#125;end","categories":[{"name":"计量","slug":"计量","permalink":"http://xiaoximu.top/categories/%E8%AE%A1%E9%87%8F/"}],"tags":[{"name":"mata","slug":"mata","permalink":"http://xiaoximu.top/tags/mata/"}]},{"title":"stata-如何快速合并多个文件夹下的数据文件","slug":"stata-如何快速合并多个文件夹下的数据文件","date":"2020-04-24T12:47:38.000Z","updated":"2020-04-24T13:40:29.739Z","comments":true,"path":"stata-如何快速合并多个文件夹下的数据文件.html","link":"","permalink":"http://xiaoximu.top/stata-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6.html","excerpt":"从各种数据库中下载下来.csv文件后，这些文件往往都会存在1998-2019等多个文件夹中。而且这些.csv文件都是以中文命名的没有规律的文件。而处理数据往往是要对这整个面板数据处理的。因此，如何合并成一个数据文件就成为了一个难题。","text":"从各种数据库中下载下来.csv文件后，这些文件往往都会存在1998-2019等多个文件夹中。而且这些.csv文件都是以中文命名的没有规律的文件。而处理数据往往是要对这整个面板数据处理的。因此，如何合并成一个数据文件就成为了一个难题。 解决思路与难点解决思路使用循环语句对各个文件夹进行处理。并将处理好的文件存储到一个新文件夹内。然后再将这个文件夹内的所有数据合并为一个.dta文件。 难点如何通过命令进入各个文件夹以及如何快速合并各个文件夹内的.csv据。 对策使用rcd获取文件夹的信息。并存储到暂元中使用openall合并.csv或.dta文件。使用cd进入各个文件夹中参见help rcd，help openall,help openall若有命令stata提示未安装，可使用ssc install openall命令进行安装。 代码的实现代码12345678910111213qui rcdlocal k = 1997 //当前文件夹forvalues i = 1(1)`r(tdirs)'&#123; cd `c(sysdir_personal)'TFP\\example qui rcd cd \"`r(ndir`i')'\" openall *,insheet //合并当前文件数据 local k = `k' + 1 dis `k' //作者本人为了方便查看代码运行结果 cd `c(sysdir_personal)'TFP\\data //将文件全部保存至data save `k'.dta ,replace //保存为.dta文件，以年份命名 clear&#125; 代码的详细介绍qui rcd是获取当前文件夹下所有文件的目录。运行此命令后，结果如下使用return list命令查看存储 如图可以看到暂元r(tdirs)中存储的是共有多少个文件夹.暂元r(ndiri)中存储的是各个文件夹的路径名。openall *,insheet是合并当前文件夹下的所有.csv文件。如果不加option选项insheet则是合并所有.dta文件。 注意在循环语句中也是要用rcd命令重新获取当前文件的路径。否则循环一次便会进入data路径内。且每个读者需自行选择进入那个文件夹以适配自己的需要。","categories":[{"name":"计量","slug":"计量","permalink":"http://xiaoximu.top/categories/%E8%AE%A1%E9%87%8F/"}],"tags":[{"name":"数据清洗","slug":"数据清洗","permalink":"http://xiaoximu.top/tags/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"}]},{"title":"要不要为stata增加一个IDE编辑器","slug":"要不要为stata增加一个IDE编辑器","date":"2020-04-17T07:04:06.000Z","updated":"2020-04-18T12:49:16.486Z","comments":true,"path":"要不要为stata增加一个IDE编辑器.html","link":"","permalink":"http://xiaoximu.top/%E8%A6%81%E4%B8%8D%E8%A6%81%E4%B8%BAstata%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AAIDE%E7%BC%96%E8%BE%91%E5%99%A8.html","excerpt":"为什么写这篇文章之前看到连玉君老师的连享会的公众号上发了几篇关于stata编辑器的文章。但是，感觉那几款编辑器都不太适合我，因为那几款编辑器支持的语言有些少，界面我也不太喜欢。所以就鼓捣了下vs code做stata的编辑器。今天记录下我折腾的过程。","text":"为什么写这篇文章之前看到连玉君老师的连享会的公众号上发了几篇关于stata编辑器的文章。但是，感觉那几款编辑器都不太适合我，因为那几款编辑器支持的语言有些少，界面我也不太喜欢。所以就鼓捣了下vs code做stata的编辑器。今天记录下我折腾的过程。 为什么用vs code做stata的编辑器vs code是微软旗下开发的一款代码编辑器。其兼容性很好，而且体积较小。用vs code的作为stata编辑器的原因主要有以下几点： vs code可以编辑多种软件的代码，例如其自带的python,R,markdown等，以及你可以同样自行添加的matlab，lex等. vs code的高亮显示功能比较好。 vs code对于编辑代码具有更流畅的体验，这体现在多方面，例如每次的换行，行数的标示，页面的展示以及上面提到的高亮功能，等等。 作者安装的stata 16不能无法直接打开.do文件。必须进入stata操作页面打开。 如何用vs code作为stata的编辑器-以stata16为例 安装vs code vs code的安装较为简单，安装过程中一直选择默认即可。因此，此处就不再赘述。 下载rundolines与 rundo这两个文件是Friedrich Huebler开发的。两个文件的下载，你可以直接点击上面标题下载，而如果由于无法科学上网不能下载的话，文末也会提供百度链接。 配置rundolines与rundo解压两个文件，解压之后将文件放置在stata16/personal路径下。由于两个文件的配置方法相同，所以之后便以配置rundo文件为例。打开rundo51文件夹下的rundo.ini文件，如果你已经安装了vs code便可以用vs code打开，如果没有，也可以用记事本格式打开。修改statapath = &quot;C:\\Program Files (x86)\\Stata15\\StataSE-64.exe&quot;为你电脑中stata的启动路径。修改statawin = &quot;Stata/SE 15.0&quot; 为你当前软件的版本号，版本号可以在打开的stata软件的左上角看到。需注意修改的代码为开头没有;的代码。 配置vs code首先在vs code的应用商店，也就是vs code左边框的第五个选项，如下图所示：在该应用商店中搜索stata enhanced与code runner两款插件，并安装。 （同时如果英文不好的话，建议安装chineses这个中文插件） 在安装完成后，我们需要将以下代码 123456789&#123; \"code-runner.executorMapByFileExtension\":&#123; \".do\":\"D:\\\\Qnap\\\\stata项目\\\\vscode编辑stata\\\\rundo.exe\"&#125;, \"code-runner.customCommand\": \"D:\\\\Qnap\\\\stata项目\\\\vscode编辑stata\\\\rundolines.exe\", \"stataRun.stataPath\": \"C:\\\\Program Files\\\\Stata16\\\\StataMP-64.exe\", \"stataRun.whichApp\": \"stataMP\", \"stataRun.pasteSpeed\": 1, \"stataRun.advancePosition\": false,&#125; 粘贴进code runner的配置文件。同时修改其相对路径。如果不知道code runner的配置文件在哪里，可参考下图。至此便全部配置完成。 rundo文件的百度链接：https://pan.baidu.com/s/1GfEcO1n0GvDYeiyCXlQ6Hg提取码：w0zh","categories":[{"name":"计量","slug":"计量","permalink":"http://xiaoximu.top/categories/%E8%AE%A1%E9%87%8F/"}],"tags":[{"name":"便捷","slug":"便捷","permalink":"http://xiaoximu.top/tags/%E4%BE%BF%E6%8D%B7/"}]}],"categories":[{"name":"计量","slug":"计量","permalink":"http://xiaoximu.top/categories/%E8%AE%A1%E9%87%8F/"}],"tags":[{"name":"R语言","slug":"R语言","permalink":"http://xiaoximu.top/tags/R%E8%AF%AD%E8%A8%80/"},{"name":"DEA","slug":"DEA","permalink":"http://xiaoximu.top/tags/DEA/"},{"name":"mata","slug":"mata","permalink":"http://xiaoximu.top/tags/mata/"},{"name":"数据清洗","slug":"数据清洗","permalink":"http://xiaoximu.top/tags/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"},{"name":"便捷","slug":"便捷","permalink":"http://xiaoximu.top/tags/%E4%BE%BF%E6%8D%B7/"}]}